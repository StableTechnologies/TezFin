
tmintallowedparamsctoken=0
tmintallowedparamsminter=1
tmintallowedparamsmintamount=2

tborrowallowedparamsctoken=0
tborrowallowedparamsborrower=1
tborrowallowedparamsborrowamount=2

tredeemallowedparamsctoken=0
tredeemallowedparamsredeemer=1
tredeemallowedparamsredeemamount=2

trepayborrowallowedparamsctoken=0
trepayborrowallowedparamspayer=1
trepayborrowallowedparamsborrower=2
trepayborrowallowedparamsrepayamount=3

ttransferallowedparamsctoken=0
ttransferallowedparamsrsrc=1
ttransferallowedparamsdst=2
ttransferallowedparamstransfertokens=3

taccountliquidityparamsctokenmodify=0
taccountliquidityparamsaccount=1
taccountliquidityparamsredeemtokens=2
taccountliquidityparamsborrowamount=3

tgetaccountliquidityparamsdata=0
tgetaccountliquidityparamscallback=1

tliquidatecalculateseizetokensctokenborrowed=0
tliquidatecalculateseizetokensctokencollateral=1
tliquidatecalculateseizetokensactualrepayamount=2

tliquidateborrowallowedctokenborrowed=0
tliquidateborrowallowedctokencollateral=1
tliquidateborrowallowedborrower=2
tliquidateborrowallowedliquidator=3
tliquidateborrowallowedrepayamount=4


define tliquidity(liquidity, updateLevel, valid){
#     tliquidity[0]=liquidity  # Current account liquidity. Negative value indicates shortfall
#     tliquidity[1]=updateLevel  # Block level of last update
#     tliquidity[2]=valid  # Liquidity is valid only for one user action
}
# 
# TLiquidity = sp.TRecord(
#     liquidity=sp.TInt,  # Current account liquidity. Negative value indicates shortfall
#     updateLevel=sp.TNat,  # Block level of last update
#     valid=sp.TBool  # Liquidity is valid only for one user action
# )
# 
# 


#     tliquidity[0]=
#     
define getliquidity(tliquidity){
	return tliquidity[0];
}

define setliquidity(tliquidity,liquidity){
	tliquidity[0] = tliquidity;
	return tliquidity
}  # Current account liquidity. Negative value indicates shortfall
#     tliquidity[1]=
#     
define getupdateLevel(tliquidity){
	return tliquidity[1];
}

define setupdateLevel(tliquidity,updateLevel){
	tliquidity[1] = tliquidity;
	return tliquidity
}  # Block level of last update
#     tliquidity[2]=
#     
define getvalid(tliquidity){
	return tliquidity[2];
}

define setvalid(tliquidity,valid){
	tliquidity[2] = tliquidity;
	return tliquidity
}  # Liquidity is valid only for one user action



define tmarket(collateralFactor, mintPaused, borrowPaused, name, price, priceExp, updateLevel, borrowCap) {

                      tmarket[0]=collateralFactor
                      # For instance, 0.9 to allow borrowing 90% of collateral value.
                      # Must be between 0 and 1, and stored as a mantissa.
                      tmarket[1]=mintPaused
                      tmarket[2]=borrowPaused
                      tmarket[3]=name  # Asset name for price oracle
                      tmarket[4]=price  # The price of the asset
                      tmarket[5]=priceExp  # exponent needed to normalize the token prices to 10^18
                      tmarket[6]=updateLevel  # Block level of last price update
                      tmarket[7]=borrowCap  # Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing
}

#                      tmarket[1]=
#                      
define getmintPaused(tmarket){
	return tmarket[1];
}

define setmintPaused(tmarket,mintPaused){
	tmarket[1] = tmarket;
	return tmarket
}
#                      tmarket[2]=
#                      
define getborrowPaused(tmarket){
	return tmarket[2];
}

define setborrowPaused(tmarket,borrowPaused){
	tmarket[2] = tmarket;
	return tmarket
}
#                      tmarket[3]=
#                      
define getname(tmarket){
	return tmarket[3];
}

define setname(tmarket,name){
	tmarket[3] = tmarket;
	return tmarket
}  # Asset name for price oracle


#                      tmarket[4]=
#                      
define getprice(tmarket){
	return tmarket[4];
}

define setprice(tmarket,price){
	tmarket[4] = tmarket;
	return tmarket
}  # The price of the asset
#                      tmarket[5]=
#                      
define getpriceExp(tmarket){
	return tmarket[5];
}

define setpriceExp(tmarket,priceExp){
	tmarket[5] = tmarket;
	return tmarket
}  # exponent needed to normalize the token prices to 10^18
#                      tmarket[6]=
#                      
define getupdateLevel(tmarket){
	return tmarket[6];
}

define setupdateLevel(tmarket,updateLevel){
	tmarket[6] = tmarket;
	return tmarket
}  # Block level of last price update
#                      tmarket[7]=
#                      
define getborrowCap(tmarket){
	return tmarket[7];
}

define setborrowCap(tmarket,borrowCap){
	tmarket[7] = tmarket;
	return tmarket
}  # Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing



# TMarket = sp.TRecord(isListed=sp.TBool,  # Whether or not this market is listed
#                      # Multiplier representing the most one can borrow against their collateral in this market.
#                      collateralFactor=Exponential.TExp,
#                      # For instance, 0.9 to allow borrowing 90% of collateral value.
#                      # Must be between 0 and 1, and stored as a mantissa.
#                      mintPaused=sp.TBool,
#                      borrowPaused=sp.TBool,
#                      name=sp.TString,  # Asset name for price oracle
#                      price=Exponential.TExp,  # The price of the asset
#                      priceExp=sp.TNat,  # exponent needed to normalize the token prices to 10^18
#                      updateLevel=sp.TNat,  # Block level of last price update
#                      borrowCap=sp.TNat  # Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing
#                      )
# 
# TLiquidity = sp.TRecord(
#     liquidity=sp.TInt,  # Current account liquidity. Negative value indicates shortfall
#     updateLevel=sp.TNat,  # Block level of last update
#     valid=sp.TBool  # Liquidity is valid only for one user action
# )
# 
# DEFAULT_COLLATERAL_FACTOR = int(5e17)  # 50 %
# 
# 
# class Comptroller(CMPTInterface.ComptrollerInterface, Exponential.Exponential, SweepTokens.SweepTokens, OP.OperationProtector):
#     def __init__(self, administrator_, oracleAddress_, closeFactorMantissa_, liquidationIncentiveMantissa_, **extra_storage):
#         Exponential.Exponential.__init__(
#             self,
#             administrator=administrator_,
#             pendingAdministrator=sp.none,
#             # Official mapping of cTokens -> Market metadata. Used e.g. to determine if a market is supported
#             markets=sp.big_map(l={}, tkey=sp.TAddress, tvalue=TMarket),
#             # The mapping of Market names -> CToken
#             marketNameToAddress=sp.map(tkey=sp.TString, tvalue=sp.TAddress),
#             transferPaused=sp.bool(True),
#             # Per-account mapping of collaterals, capped by maxAssets
#             collaterals=sp.big_map(
#                 l={}, tkey=sp.TAddress, tvalue=sp.TSet(sp.TAddress)),
#             # Per-account mapping of loans, capped by maxAssets
#             loans=sp.big_map(l={}, tkey=sp.TAddress,
#                              tvalue=sp.TSet(sp.TAddress)),
#             # Per-account mapping of current liquidity
#             account_liquidity=sp.big_map(
#                 l={}, tkey=sp.TAddress, tvalue=TLiquidity),
#             oracleAddress=oracleAddress_,
#             # Set of currently active operations to protect execution flow
#             activeOperations=sp.set(t=sp.TNat),
#             closeFactorMantissa=closeFactorMantissa_,
#             liquidationIncentiveMantissa=liquidationIncentiveMantissa_,
#             **extra_storage
#         )
# 


             comptrolleradministrator=0  
             comptrollerpendingadministrator=1  
             # official mapping of ctokens -> market metadata. used e.g. to determine if a market is supported
             comptrollermarkets=2   
             # the mapping of market names -> ctoken
             comptrollermarketnametoaddress=3  
             comptrollertransferpaused=4  
             # per-account mapping of collaterals, capped by maxassets
             comptrollercollaterals=5  
             # per-account mapping of loans, capped by maxassets
             comptrollerloans=6   
             # per-account mapping of current liquidity
             comptrolleraccountliquidity=7  
             comptrolleroracleaddress=8  
             # set of currently active operations to protect execution flow
             comptrolleractiveoperations=9  
             comptrollerclosefactormantissa=10  
             comptrollerliquidationincentivemantissa=11  

define comptroller(state, administrator, pendingadministrator, markets, marketnametoaddress, transferpaused, collaterals, loans, accountliquidity, oracleaddress, activeoperations, closefactormantissa, liquidationincentivemantissa){
	
             state[comptrolleradministrator] = administrator
             state[comptrollerpendingadministrator] = pendingadministrator
             # official mapping of ctokens -> market metadata. used e.g. to determine if a market is supported
             state[comptrollermarkets] = markets
             # the mapping of market names -> ctoken
             state[comptrollermarketnametoaddress] =  marketnametoaddress
             state[comptrollertransferpaused] = transferpaused
             # per-account mapping of collaterals, capped by maxassets
             state[comptrollercollaterals] = collaterals
             # per-account mapping of loans, capped by maxassets
             state[comptrollerloans] = loans
             # per-account mapping of current liquidity
             state[comptrolleraccountliquidity] = accountliquidity
             state[comptrolleroracleaddress] = oracleaddress
             # set of currently active operations to protect execution flow
             state[comptrolleractiveoperations] = account
             state[comptrollerclosefactormantissa] = closefactormantissa
             state[comptrollerliquidationincentivemantissa] = liquidationincentivemantissa

}


	     
define getadministrator(comptroller){
	return comptroller[comptrolleradministrator];
}

define setadministrator(comptroller,administrator){
	comptroller[comptrolleradministrator] = comptroller;
	return comptroller
}

define getpendingadministrator(comptroller){
	return comptroller[1];
}

define setpendingadministrator(comptroller,pendingadministrator){
	comptroller[1] = comptroller;
	return comptroller
}
# official mapping of ctokens -> market metadata. used e.g. to determine if a market is supported

define getmarkets(comptroller){
	return comptroller[2];
}

define setmarkets(comptroller,markets){
	comptroller[2] = comptroller;
	return comptroller
}
# the mapping of market names -> ctoken

define getmarketnametoaddress(comptroller){
	return comptroller[3];
}

define setmarketnametoaddress(comptroller,marketnametoaddress){
	comptroller[3] = comptroller;
	return comptroller
}

define gettransferpaused(comptroller){
	return comptroller[4];
}

define settransferpaused(comptroller,transferpaused){
	comptroller[4] = comptroller;
	return comptroller
}
# per-account mapping of collaterals, capped by maxassets
define getcollaterals(comptroller){
	return comptroller[5];
}

define setcollaterals(comptroller,collaterals){
	comptroller[5] = comptroller;
	return comptroller
}
# per-account mapping of loans, capped by maxassets

define getloans(comptroller){
	return comptroller[6];
}

define setloans(comptroller,loans){
	comptroller[6] = comptroller;
	return comptroller
} 
# per-account mapping of current liquidity

define getaccountliquidity(comptroller){
	return comptroller[7];
}

define setaccountliquidity(comptroller,accountliquidity){
	comptroller[7] = comptroller;
	return comptroller
}

define getoracleaddress(comptroller){
	return comptroller[8];
}

define setoracleaddress(comptroller,oracleaddress){
	comptroller[8] = comptroller;
	return comptroller
}
# set of currently active operations to protect execution flow

define getactiveoperations(comptroller){
	return comptroller[9];
}

define setactiveoperations(comptroller,activeoperations){
	comptroller[9] = comptroller;
	return comptroller
}

define getclosefactormantissa(comptroller){
	return comptroller[10];
}

define setclosefactormantissa(comptroller,closefactormantissa){
	comptroller[10] = comptroller;
	return comptroller
}

define getliquidationincentivemantissa(comptroller){
	return comptroller[11];
}

define setliquidationincentivemantissa(comptroller,liquidationincentivemantissa){
	comptroller[11] = comptroller;
	return comptroller
}
true=1;
false=0;

define contains(items, item){
       for (n=0;items[n];n++){
            if (items[n]=item) {
               return true;
            }
	}
	return false;
}

#     """
#         Add assets to be included in account liquidity calculation
# 
#         cTokens: TList(TAddress) - The list of addresses of the cToken markets to be enabled
#     """
#     @sp.entry_point(lazify=True)
#     define enterMarkets(cTokens, sender) {
#             for (n=0;cTokens[n];n++){
#                  addToCollaterals(token, sender)
#             }
#         self.invalidateLiquidity(sp.sender)
# }# 
#     define addToCollaterals(cToken, lender) {
#         self.verifyMarketListed(cToken)
#         sp.if self.data.collaterals.contains(lender):
#             self.data.collaterals[lender].add(cToken)
#         sp.else:
#             self.data.collaterals[lender] = sp.set([cToken])
# }# 
# 
# 
# 
#     define verifyMarketListed(token) {
#         sp.verify(self.data.markets.contains(token) &
#                   self.data.markets[token].isListed, EC.CMPT_MARKET_NOT_LISTED)
# }# 
# 
#     
#     define invalidateLiquidity(self, account) {
#         sp.if self.data.account_liquidity.contains(account):
#             self.data.account_liquidity[account].valid = False
# }





